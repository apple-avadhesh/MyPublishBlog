<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>肘子的Swift记事本</title><description>徐杨的个人博客,Core Data,Swift,Swift UI,Combine,健康笔记,iOS APP,Health Note,HealthNotes</description><link>https://www.fatbobman.com</link><language>zh</language><lastBuildDate>Wed, 15 Sep 2021 14:31:59 +0800</lastBuildDate><pubDate>Wed, 15 Sep 2021 14:31:59 +0800</pubDate><ttl>250</ttl><atom:link href="https://www.fatbobman.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.fatbobman.com/posts/newInteractiveDismissDiabled</guid><title>如何在SwiftUI中实现interactiveDismissDisabled</title><description>本文中我们将探讨如何实现一个SwiftUI 3.0中新增功能——interactiveDismissDisabled的增强版；如何创建更SwiftUI化的功能扩展。</description><link>https://www.fatbobman.com/posts/newInteractiveDismissDiabled</link><pubDate>Wed, 15 Sep 2021 14:30:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文中我们将探讨如何实现一个SwiftUI 3.0中新增功能——interactiveDismissDisabled的增强版；如何创建更SwiftUI化的功能扩展。</p></blockquote><h2>需求</h2><p>由于<a href="https://www.fatbobman.com/healthnotes/">健康笔记</a>中数据录入都是在Sheet中进行的，为了防止用户在录入过程中由于误操作（使用手势取消Sheet）丢失数据，因此，从最初的版本开始，我就一直使用各种手段加强对Sheet的控制。</p><p>去年9月，我在文章<a href="https://www.fatbobman.com/posts/swiftui-dismiss-sheet/">【在SwiftUI中制作可以控制取消手势的Sheet】</a>中介绍了<a href="https://www.fatbobman.com/healthnotes/">健康笔记2.0</a>版本的Sheet控制实现方法。目标为：</p><ul><li>通过代码控制是否允许手势取消Sheet</li><li>在用户使用手势取消Sheet时可以获得通知，进而拥有更多的控制能力</li></ul><p>最终实现的效果如下：</p><p>当用户有未保存的数据时，通过手势取消Sheet将被阻止，用户需明确选择保存或丢弃数据。</p><p>最终的效果已经完全满足了我的要求，不过唯一遗憾的是，使用起来不是那么的直观（具体使用方式请查看<a href="https://www.fatbobman.com/posts/swiftui-dismiss-sheet/">原文</a>）。</p><p>在今年推出的SwiftUI 3.0版本中，苹果添加了一个新的View扩展：<code>interactiveDis<a href=https://www.fatbobman.com/posts/newInteractiveDismissDiabled>...></a></code></p><br><br><h3><a href=https://www.fatbobman.com/posts/newInteractiveDismissDiabled>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-6</guid><title>Core Data with CloudKit (六) —— 共享数据</title><description>本文中，我们将探讨如何使用Core Data with CloudKit创建使用NSPersistentCloudKitContainer与多个iCloud用户共享数据的应用。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-6</link><pubDate>Sat, 11 Sep 2021 19:20:00 +0800</pubDate><content:encoded><![CDATA[<p>本文中，我们将探讨如何使用Core Data with CloudKit创建与多个iCloud用户共享数据的应用。</p><blockquote><p>本篇是本系列的最后一篇，本文中将涉及大量之前提到的知识，阅读本文前，最好已经阅读过之前的<a href="https://www.fatbobman.com/tags/cloudkit/">文章</a>。</p></blockquote><p>相信应该有不少的朋友都使用过iOS自带的共享相簿或者共享备忘录功能。这些功能的实现都是基于几年前苹果推出的CloudKit共享数据API。在WWDC 2021中，苹果将该功能集成到Core Data with CloudKit之中，我们终于可以在使用少量CloudKit API的情况下，用Core Data的操作方式创建具有同样功能的应用程序了。</p><p>就像WWDC session <a href="https://developer.apple.com/videos/play/wwdc2021/10015/" target="_blank">Build apps that share data through CloudKit and Core Data</a>提到的那样，共享数据功能的实现远复杂于同步私有数据库以及同步公共数据库。尽管苹果提供了不少新的API来简化该操作，但想完整的在应用程序中实现该功能仍具有不小的挑战。</p><h2>基础</h2><blockquote><p>本节主要介绍的是Core Dat<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-6>...></a></p></blockquote><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-6>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/async-await-store</guid><title>用Async/Await重建SwiftUI的Redux-like状态容器</title><description>本文介绍了如何使用Swift 5.5版本的Async/Await功能重构SwiftUI的状态容器代码。</description><link>https://www.fatbobman.com/posts/async-await-store</link><pubDate>Mon, 6 Sep 2021 11:05:00 +0800</pubDate><content:encoded><![CDATA[<p>经过两年多的时间，SwiftUI发展到当前的3.0版本，无论SwiftUI的功能还是Swift语言本身在这段时间里都有了巨大的提升。是时候使用Async/Await来重构我的的状态容器代码了。</p><h2>SwiftUI的状态容器</h2><p>我是从王巍的<a href="https://objccn.io/products/" target="_blank">SwiftUI与Combine编程</a>一书中，第一次接触到<code>Single souce of truth</code>式的编程思想。整体来说，同Redux的逻辑基本一致：</p><ul><li>将App当做状态机，UI是App状态（State）的具体呈现。</li><li>State（值类型）被保存在一个Store对象当中，为了在视图中注入方便，Store需符合<code>ObservableObject</code>协议，且为State设置<code>@Published</code>属性包装，保证State的任何变化都将被及时响应。</li><li>View不能直接修改State，只能通过发送Action间接改变Store中的State内容</li><li>Store中的Reducer负责处理收到的Action，并按照Action的要求变更State</li></ul><p>通常，对State、Store和Action的定义如下：</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">st<a href=https://www.fatbobman.com/posts/async-await-store>...></a></span></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/async-await-store>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/NavigationViewKit</guid><title>用NavigationViewKit增强SwiftUI的导航视图</title><description>由于SwiftUI原生提供的导航手段能力有限，因此在之前的版本中，NavigationView总是使用的不是那么的顺手。本文介绍一个我写的针对NavigationView的扩展库——NavigationViewKit。为原生NavigationView解决几个当前的痛点问题。</description><link>https://www.fatbobman.com/posts/NavigationViewKit</link><pubDate>Mon, 30 Aug 2021 20:10:00 +0800</pubDate><content:encoded><![CDATA[<p>最近一直在为我的iOS健康管理app<a href="https://www.fatbobman.com/healthnotes/">健康笔记3.0</a>做前期的准备工作。</p><p>由于SwiftUI原生提供的导航手段能力有限，因此在之前的版本中，NavigationView总是使用的不是那么的顺手。有以下几个我不满意的地方：</p><ul><li>缺少直接返回根视图的便捷手段</li><li>无法通过代码（不通过<code>NavigationLink</code>）跳转到新视图</li><li>双栏模式（<code>DoubleColumnNavigationViewStyle</code>）下显示风格不统一</li><li>在iPad下，无法在竖屏（Portrait）模式下保持双栏状态</li></ul><p>因此，在这次开发的准备阶段，我写了一个针对NavigationView的扩展库——<a href="https://github.com/fatbobman/NavigationViewKit" target="_blank">NavigationViewKit</a>。该扩展遵循以下几个原则：</p><ul><li>非破坏性</li></ul><p>任何新添加的功能都不能影响当前SwiftUI提供的原生功能，尤其是不能影响例如<code>Toolbar</code>、<code>NavigationLink</code>在NavigationView中的表现</p><ul><li>尽可能便于使用</li></ul><p>仅需极少的代码便可使用新增功能</p><ul><li>SwiftUI原生风格</li></ul><p>扩展功能的调用方法尽可能同原生SwiftUI方式类似</p><blockquote><p>请访问Githu<a href=https://www.fatbobman.com/posts/NavigationViewKit>...></a></p></blockquote><br><br><h3><a href=https://www.fatbobman.com/posts/NavigationViewKit>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataInPreview</guid><title>如何在Xcode下预览含有Core Data元素的SwiftUI视图</title><description>本文将探讨导致SwiftUI预览崩溃的部分原因，如何在之后的开发中避免类似的崩溃出现以及如何在Xcode中安全可靠地预览含有Core Data元素的SwiftUI视图</description><link>https://www.fatbobman.com/posts/coreDataInPreview</link><pubDate>Sat, 28 Aug 2021 08:20:00 +0800</pubDate><content:encoded><![CDATA[<p>从SwiftUI诞生之日起，预览（Canvas Preview ）一直是个让开发者又爱又恨的功能。当预览正常工作时，它可以极大地提高开发效率；而预览又随时可能因为各种莫名其妙的原因崩溃，不仅影响开发进程，同时又让开发者感到沮丧（很难排查出导致预览崩溃的故障）。</p><p>在预览含有Core Data元素的视图时崩溃的出现次数会愈发频繁，在某种程度上可能已经影响了开发者在SwiftUI中使用Core Data的热情。</p><p>结合两年来我在SwiftUI中使用Core Data的经验和教训，我们将在本文中探讨：</p><ul><li>导致SwiftUI预览崩溃的部分原因</li><li>如何在之后的开发中避免类似的崩溃出现</li><li>如何在Xcode中安全可靠地预览含有Core Data元素的SwiftUI视图</li></ul><h2>预览</h2><h3>预览是模拟器</h3><p>预览是模拟器，是一个高度优化且精简的模拟器。</p><p>预览在Xcode中的<strong>工作原理</strong>同标准的模拟器十分接近。但为了让它可以即时响应SwiftUI视图的变化，苹果对其做出了不少的修改。如果说标准的模拟器可以涵盖真实设备的90%的功能，那么用于预览的模拟器可<a href=https://www.fatbobman.com/posts/coreDataInPreview>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataInPreview>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/uikitInSwiftUI</guid><title>在SwiftUI中使用UIKit视图</title><description>本文将通过对UITextField的包装来讲解如何在SwiftUI中使用UIKit视图、如何让你的UIKit包装视图具有SwiftUI风格、在SwiftUI使用UIKit视图需要注意的地方</description><link>https://www.fatbobman.com/posts/uikitInSwiftUI</link><pubDate>Mon, 23 Aug 2021 11:12:00 +0800</pubDate><content:encoded><![CDATA[<p>已迈入第三个年头的SwiftUI相较诞生初始已经提供了更多的原生功能，但仍有大量的事情是无法直接通过原生SwiftUI代码来完成的。在相当长的时间中开发者仍需在SwiftUI中依赖UIKit（AppKit）代码。好在，SwiftUI为开发者提供了便捷的方式将UIKit（AppKit）视图（或控制器）包装成SwiftUI视图。</p><p>本文将通过对UITextField的包装来讲解以下几点：</p><ul><li>如何在SwiftUI中使用UIKit视图</li><li>如何让你的UIKit包装视图具有SwiftUI风格</li><li>在SwiftUI使用UIKit视图需要注意的地方</li></ul><blockquote><p><strong>如果你已经对如何使用<code>UIViewRepresentable</code>有所掌握，可以直接从<code>SwiftUI风格化</code>部分阅读</strong></p></blockquote><h2>基础</h2><p>在具体演示包装代码之前，我们先介绍一些与在SwiftUI中使用UIKit视图有关的基础知识。</p><blockquote><p>无需担心是否能立即理解下述内容，在后续的演示中会有更多的内容帮助你掌握相关知识。</p></blockquote><h3>生命周期</h3><p>SwiftUI同UIKit和AppKit的主要区别之一是，SwiftUI的视图（View）<a href=https://www.fatbobman.com/posts/uikitInSwiftUI>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/uikitInSwiftUI>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/blogUpgrade</guid><title>博客更新记</title><description>上个周末，我将博客进行了一番装修升级。我对本次更新的效果比较满意，并非博客变得多好，而是通过此次更新，让我对当今的Web技术有了一定的了解。同时在本次更新过程中，无论是调试Swift代码、CSS代码还是Markdown文档，都是在Visual Studio Code中进行的，这也让我对Visual Studio Code有了进一步的认识和掌握。</description><link>https://www.fatbobman.com/posts/blogUpgrade</link><pubDate>Tue, 17 Aug 2021 18:30:00 +0800</pubDate><content:encoded><![CDATA[<p>上个周末，我将本博客进行了一番装修升级。我对本次更新的效果比较满意，并非博客变得多好，而是通过此次更新，让我对当今的Web技术有了一定的了解。同时在本次更新过程中，无论是调试Swift代码、CSS代码还是Markdown文档，都是在Visual Studio Code中进行的，这也让我对Visual Studio Code有了进一步的认识和掌握。</p><p>通过本文将这几天更新过程记录下来。</p><blockquote><p>作为一个使用CSS、javascript仅几天的人来说，本文的内容可能并不正确或相当偏颇，望见谅。</p></blockquote><h2>本次更新目标</h2><p>在完全停止写博客和写代码超过15年后，2020年我重新创建了自己的个人博客。目的同之前的博客一样，记录并分享自己的编程学习心得、体会、经验和教训。</p><p>本博客的主题是记录有关Swift学习方面的内容，因此在使用了一段时间的WordPress、Hexo后，我找到了一个由Swift编写的静态站点生成器<a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a>，并用它完成了博客的第一次重大调整。</p><blockquote><p>如果对Publish感兴趣，可以阅读我写的几篇Publsih的介绍<a href=https://www.fatbobman.com/posts/blogUpgrade>...></a></p></blockquote><br><br><h3><a href=https://www.fatbobman.com/posts/blogUpgrade>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-5</guid><title>Core Data with CloudKit（五）——同步公共数据库</title><description>本文将介绍如何通过Core Data with CloudKit将公共数据库同步到本地，在本地创建Core Data数据库镜像。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-5</link><pubDate>Fri, 13 Aug 2021 19:22:00 +0800</pubDate><content:encoded><![CDATA[<p>本文将介绍如何通过<code>Core Data with CloudKit</code>将公共数据库同步到本地，在本地创建<code>Core Data</code>数据库镜像。</p><h2>三种CloudKit数据库</h2><p>介绍一下<code>CloudKit</code>中的三种数据库：</p><h3>公共数据库</h3><p>公共数据库存放的是开发者希望任何人都能够访问的数据。不可以在公共数据库中添加自定义<code>Zone</code>，所有的数据都保存在默认的区域中。无论用户是否有<code>iCloud</code>账户，都可以通过应用程序或<code>CloudKit Web</code>服务访问其中的数据。公共数据库的内容在<code>CloudKit</code>仪表台是可见的。</p><p>公共数据库的数据容量计入应用程序的<code>CloudKit</code>存储配额。</p><h3>私有数据库</h3><p>这是<code>iCloud</code>用户存储个人数据的地方，用户将不希望公众看到的内容通过应用程序保存在这里。只有在登录了<code>iCloud</code>账户后，用户才可以访问其中的数据。默认情况下，只有用户本人才能访问自己的私有数据库中的内容（可将部分内容分享给其他的<code>iCloud</code>用户）。用户对数据拥有全部的操作权限（创建、查看、更改、删除）。私有数据库中的数据在<code>CloudKit</code>仪表台中是不可<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-5>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-5>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-4</guid><title>Core Data with CloudKit（四）—— 调试、测试、迁移及其他</title><description>本文聊一下在开发Core Data with CloudKit项目中常见的一些问题，让大家少走弯路、避免踩坑。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-4</link><pubDate>Wed, 11 Aug 2021 07:50:00 +0800</pubDate><content:encoded><![CDATA[<p>本文聊一下在开发<code>Core Data with CloudKit</code>项目中常见的一些问题，让大家少走弯路、避免踩坑。</p><h2>控制台日志信息</h2><p>一个支持<code>Core Data with CloudKit</code>的项目，控制台输出将常态化地成为上图状态。</p><p>每个项目面对的情况不同且信息中的废话较多，因此我仅就可能的信息种类做一下归纳。</p><h3>正常情况的信息</h3><ul><li><strong>初始化信息</strong></li></ul><p>代码启动后，通常首先出现在控制台的便是<code>NSPersistentCloudKitContainer</code>展示的初始化信息。包括：成功在指定<code>url</code>创建了容器，成功启用了<code>NSCloudKitMirroringDelegate</code>同步响应等。如果是首次运行项目，还会有成功在<code>iCloud</code>上创建了<code>Schema</code>之类的提示。</p><ul><li><strong>数据模型迁移信息</strong></li></ul><p>如果本地和服务器端的数据模型不一致，会出现迁移提醒。有时即使本地的<code>Core Data</code>模型和<code>iCloud</code>上的模型一致，也会看到类似<code>Skipping migration for 'ANSCKDATABASEMETADATA' because it already h<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-4>...></a></code></p><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-4>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-3</guid><title>Core Data with CloudKit（三）——CloudKit仪表台</title><description>本篇文章中，我们将一起研究CloudKit仪表台。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-3</link><pubDate>Mon, 9 Aug 2021 17:30:00 +0800</pubDate><content:encoded><![CDATA[<p>本篇文章中，我们将一起研究<code>CloudKit</code>仪表台。</p><h2>初识仪表台</h2><p>使用<code>CloudKit Dashboard</code>需要开发者拥有<a href="https://developer.apple.com/programs/" target="_blank">Apple Developer Program</a>账号，访问<a href="https://icloud.developer.apple.com" target="_blank">https://icloud.developer.apple.com</a>即可使用。</p><p>最近两年苹果对<code>CloudKit仪表台</code>的布局做过较大的调整，上面的截图是2021年中时的样子。</p><p>仪表台主要分为三个部分：</p><ul><li>数据库（<code>CloudKit Database</code>）</li></ul><p>数据库<code>Web</code>客户端。涵盖管理<code>Schema</code>、<code>Record</code>、<code>Zone</code>、用户权限、容器环境等功能。</p><ul><li>遥测（<code>Telemetry</code>）</li></ul><p>使用直观的可视化效果，深入了解应用程序的服务器端性能以及跨数据库和推送事件的利用率。</p><ul><li>日志（<code>Logs</code>）</li></ul><p>CloudKit 服务器生成实时和历史日志，记录并显示应用程序和服务器之间的交互。</p><blockquote><p>在绝大多数使用<code>Core Data with CloudKit</code>的场景下，我们仅需要使用仪表板中极少数的功能（环境部署），但利用<code>CloudKit Dashboard</code>，我们可以更清楚的了解<code>Core <a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-3>...></a></code></p></blockquote><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-3>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-2</guid><title>Core Data with CloudKit（二）——同步本地数据库到iCloud私有数据库</title><description>本篇文章中，我们将探讨Core Data with CloudKit应用中最常见的场景——将本地数据库同步到iCloud私有数据库。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-2</link><pubDate>Mon, 9 Aug 2021 08:50:00 +0800</pubDate><content:encoded><![CDATA[<p>本篇文章中，我们将探讨<code>Core Data with CloudKit</code>应用中最常见的场景——将本地数据库同步到<code>iCloud</code>私有数据库。我们将从几个层面逐步展开：</p><ul><li>在新项目中直接支持<code>Core Data with CloudKit</code></li><li>创建可同步<code>Model</code>的注意事项</li><li>在现有项目<code>Core Date</code>中添加<code>Host in CloudKit</code>支持</li><li>有选择的同步数据</li></ul><blockquote><p>本文使用的开发环境为<code>Xcode 12.5</code>。关于私有数据库的概念，请参阅<a href="https://www.fatbobman.com/posts/coreDataWithCloudKit-1/">Core Data with CloudKit (一) —— 基础</a>。如想实际操作本文内容，需要拥有<a href="https://developer.apple.com/programs/" target="_blank">Apple Developer Program</a>账号。</p></blockquote><h2>快速指南</h2><p>在应用程序中启用<code>Core Data with CloudKi</code>t功能，只需要以下几步：</p><ol><li>使用<code>NSPersistentCloudKitContainer</code></li><li>在<code>项目Target</code>的<code>Signing&amp;Capablities</code>中添加<code>CloudKit</code>支持</li><li>为项目创建或指定<code>CloudKit container</code></li><li>在<code>项目Target</code>的<code>Signing&amp;<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-2>...></a></code></li></ol><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-1</guid><title>Core Data with CloudKit (一) —— 基础</title><description>介绍如何使用NSPersistentContainer的文章并不少，但同其他Core Data的功能一样，用好并不容易。在两年多的使用中，我便碰到不少问题。借着今年打算在【健康笔记3】中实现共享数据库功能的机会，我最近较系统地重新学习了Core Data with CloudKit并对其知识点进行了梳理。希望通过这个系列博文能让更多的开发者了解并使用Core Data with Cloudkit功能。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-1</link><pubDate>Thu, 5 Aug 2021 20:50:00 +0800</pubDate><content:encoded><![CDATA[<p>在WWDC 2019上，苹果为<code>Core Data</code>带了一项重大的更新——引入了<code>NSPersistentCloudKitContainer</code>。这意味着无需编写大量代码，使用<code>Core Data with CloudKit</code>可以让用户在他所有的苹果设备上无缝访问应用程序中的数据。</p><p><code>Core Data</code>为开发具有结构化数据的应用程序提供了强大的对象图管理功能。CloudKit允许用户在登录其iCloud账户的每台设备上访问他们的数据，同时提供一个始终可用的备份服务。<code>Core Data with CloudKit</code>则结合了本地持久化+云备份和网络分发的优点。</p><p>2020年、2021年，苹果持续对<code>Core Data with CloudKit</code>进行了强化，在最初仅支持私有数据库同步的基础上，添加了公有数据库同步以及共享数据库同步的功能。</p><p>我将通过几篇博文介绍<code>Core Data with CloudKit</code>的用法、调试技巧、控制台设置并尝试更深入地研究其同步机制。</p><h2>Core Data with CloudKit的局限性</h2><ul><li><strong>只能运<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-1>...></a></strong></li></ul><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/appstorage</guid><title>@AppStorage研究</title><description>本文探讨的是如何优雅、高效、安全地在SwiftUI中使用@AppStorage，在不借助第三方库的情况下，解决当前@AppStorage使用中出现的痛点</description><link>https://www.fatbobman.com/posts/appstorage</link><pubDate>Sat, 31 Jul 2021 18:40:00 +0800</pubDate><content:encoded><![CDATA[<h2>前言</h2><p>在苹果生态的应用中，开发者或多或少都会使用到UserDefaults。我个人习惯将可被用户自定义的配置信息（精度、单位、色彩等）保存在UserDefaults中。随着配置信息的增加，在SwiftUI视图中使用的@AppStorage越来越多。</p><p>在<a href="https://www.fatbobman.com/healthnotes/">【健康笔记3】</a>中，我计划开放更多的自定义选项给用户，简单的算下来要有40-50项，在配置视图中更会将所有用到的UserDefaults内容都注入进代码。</p><p>本文探讨的是如何优雅、高效、安全地在SwiftUI中使用@AppStorage，在不借助第三方库的情况下，解决当前@AppStorage使用中出现的痛点：</p><ul><li>支持的数据类型少</li><li>声明繁琐</li><li>声明容易出现拼写错误</li><li>大量@AppStorage无法统一注入</li></ul><h2>@AppStorage基础指南</h2><p>@AppStorage是SwiftUI框架提供的一个属性包装器，设计初衷是创建一种在视图中保存和读取UserDefaults变量的快捷方法。@AppStorage在视图中的行为同@State很类似，其值变化时将导致与其依赖的视图无效并<a href=https://www.fatbobman.com/posts/appstorage>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/appstorage>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/persistentHistoryTracking</guid><title>在CoreData中使用持久化历史跟踪</title><description>本文介绍了CoreData的Persistent History Tracking功能。详细讲解了从响应、提取、合并到清除的全过程处理方式，并提供了演示代码供读者使用。</description><link>https://www.fatbobman.com/posts/persistentHistoryTracking</link><pubDate>Tue, 27 Jul 2021 12:00:00 +0800</pubDate><content:encoded><![CDATA[<h2>前言</h2><p>知道持久化历史跟踪功能已经有一段时间了，之前简单地浏览过文档但没有太当回事。一方面关于它的资料不多，学习起来并不容易；另一方面也没有使用它的特别动力。</p><p>在计划中的<a href="https://www.fatbobman.com/healthnotes/">【健康笔记3】</a>中，我考虑为App添加Widget或者其他的Extentsion，另外我也打算将WWDC21上介绍的NSCoreDataCoreSpotlightDelegate用到App的新版本中。为此就不得不认真地了解该如何使用持久化历史跟踪功能了。</p><h2>什么是持久化历史跟踪（Persistent History Tracking）</h2><blockquote><p>使用持久化历史跟踪（Persistent History Tracking）来确定自启用该项功能以来，存储（Store）中发生了哪些更改。 —— 苹果官方文档</p></blockquote><p>在CoreData中，如果你的数据保存形式是Sqlite（绝大多数的开发者都采用此种方式）且启用了持久化历史跟踪功能，无论数据库中的数据有了何种变化（删除、添加、修改等），调用此数据库并注册了该通知的应用，都会收到一个数据库有变化的系统提醒。</p><h2>为什么<a href=https://www.fatbobman.com/posts/persistentHistoryTracking>...></a></h2><br><br><h3><a href=https://www.fatbobman.com/posts/persistentHistoryTracking>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/wwdc2021</guid><title>WWDC 2021 观后感</title><description>WWDC 2021转眼间已经结束一周了。本次WWDC苹果一如既往的带来了新的操作系统以及一大堆开发工具、软件架构、网络服务等方面的升级。由于疫情的原因，这两年的WWDC都是采用录播形式，不过从视频内容上看，反倒比以前传达地更加精准，对观看者也更加地友善。本文仅从我个人感兴趣的几个角度进行一点介绍，并结合这段时间的学习谈谈使用感受。</description><link>https://www.fatbobman.com/posts/wwdc2021</link><pubDate>Fri, 18 Jun 2021 20:00:00 +0800</pubDate><content:encoded><![CDATA[<p>WWDC 2021转眼间已经结束一周了。本次WWDC苹果一如既往的带来了新的操作系统以及一大堆开发工具、软件架构、网络服务等方面的升级。由于疫情的原因，这两年的WWDC都是采用录播形式，不过从视频内容上看，反倒比以前传达地更加精准，对观看者也更加地友善。本文仅从我个人感兴趣的几个角度进行一点介绍，并结合这段时间的学习谈谈使用感受。</p><h2>操作系统</h2><p>这几年苹果的系统一直保持一种渐进式的升级态势，即使是大版本号升级通常并不会给人特别大的惊喜和改变。不过也正是在这种逐步的变化中，苹果不断的将它多个系统的联系变得更加紧密，生态建设的愈发完善。网上已经有了大量关于系统新功能的文章，所以我仅从自己的使用上谈几点感受。</p><p>iOS 15在旧设备上的效率相当不错（我在一台iPhone7上进行了安装）。相较于iPhone，iPad上对于多任务、多窗口的交互提升观感更明显。在后期软件适配跟上的情况下，iPad应用或许会有一个新的爆发。Monterey第一个版本的稳定度明显好于去年的Big Sur，界面细节的统一性也不错。相<a href=https://www.fatbobman.com/posts/wwdc2021>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/wwdc2021>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swift-in-linux</guid><title>在Linux系统上搭建Swift开发调试环境</title><description>本文的目标是在Linux上搭建一个可供生产标准的Swift开发调试环境。使用者将获得一个支持代码高亮、自动补全、定义跳转、断点调试、代码美化、代码静态扫描、跨操作系统平台配置的综合开发体验。</description><link>https://www.fatbobman.com/posts/swift-in-linux</link><pubDate>Mon, 15 Feb 2021 15:00:00 +0800</pubDate><content:encoded><![CDATA[<h2>Swift与Linux</h2><p>自2015年Swift宣布开源并支持Linux后，一晃已超过5年。在最初几年间尽管Swift发展迅速，但并未被Linux社区广泛接受。造成这种局面的原因较多，其中既有语言稳定性方面的问题，同时又有对Linux的支持不完善、缺乏具有吸引力的基础库和第三方库、热点项目不足等多方面原因。</p><p>最近两年，上述问题均得到显著改善。</p><ul><li>从Swift5开始Swift团队宣布ABI稳定了。自此，Swift为应用程序提供了二进制兼容性，有了ABI稳定性作为基础，Swift对其他平台的支持速度和力度将大大提高</li><li>2020年Swift团队推出了5.3版本，除了“重要的质量提升和性能增强”之外，Swift5.3的一个关键特性是正式支持Linux和Window平台。事实上，这也是Swift的发布流程首次为三个不同的平台分别设立了发布负责人。作为承诺将Swift引入Linux的第一份成果，Swift团队宣布新的Swift版本可用于一众Linux发行版上。</li><li>出现了大量优秀的官方和第三方的跨平台库。仅Apple公<a href=https://www.fatbobman.com/posts/swift-in-linux>...></a></li></ul><br><br><h3><a href=https://www.fatbobman.com/posts/swift-in-linux>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/publish-3</guid><title>用Publish创建博客（三）——插件开发</title><description>我们不仅可以利用Publish内置的接口来开发插件进行扩展，同时还可以使用Publish套件中其他的优秀库（Ink、Plot、Sweep、Files、ShellOut等）来完成更多的创意。本文将通过几个实例（添加标签、增加属性、用代码生成内容、全文搜索、命令行部署）在展示不同扩展手段的同时向大家介绍Publish套件中其他的优秀成员。</description><link>https://www.fatbobman.com/posts/publish-3</link><pubDate>Wed, 3 Feb 2021 19:58:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>我们不仅可以利用Publish内置的接口来开发插件进行扩展，同时还可以使用Publish套件中其他的优秀库（Ink、Plot、Sweep、Files、ShellOut等）来完成更多的创意。本文将通过几个实例（添加标签、增加属性、用代码生成内容、全文搜索、命令行部署）在展示不同扩展手段的同时向大家介绍Publish套件中其他的优秀成员。在阅读本文前，最好能先阅读<a href="https://www.fatbobman.com/posts/publish-1/">用Publish创建博客（一）——入门</a>、<a href="https://www.fatbobman.com/posts/publish-2/">用Publish创建博客（二）——主题开发</a>。对Publish有个基本了解。本文篇幅较长，你可以选择自己感兴趣的实战内容阅读。</p></blockquote><h2>基础</h2><h3>PublishingContext</h3><p>在<a href="https://www.fatbobman.com/posts/publish-1/">用Publish创建博客（一）——入门</a>中我们介绍过Publish有两个Content概念。其中<code>PublishingContext</code>作为根容器包含了你网站项目的全部信息（<code>Site</code>、<code>Section</code>、<code>Item</code>、<code>Page</code>等）。在对Publish进行的大多数扩展开发时，都需要和<code>PublishingContext</code>打交道。不仅通过它来获取数据，而且<a href=https://www.fatbobman.com/posts/publish-3>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/publish-3>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/publish-2</guid><title>用Publish创建博客（二）——主题开发</title><description>拥用强大的主题系统是一个静态网站生成器能否成功的重要原因之一。Publish采用Plot作为主题的开发工具，让开发者在高效编写主题的同时享受到了Swift的类型安全的优势。本文将从Plot开始介绍，让读者最终学会如何创建Publish主题。</description><link>https://www.fatbobman.com/posts/publish-2</link><pubDate>Mon, 1 Feb 2021 16:20:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>拥用强大的主题系统是一个静态网站生成器能否成功的重要原因之一。<a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a>采用<a href="https://github.com/JohnSundell/Plot" target="_blank">Plot</a>作为主题的开发工具，让开发者在高效编写主题的同时享受到了Swift的类型安全的优势。本文将从Plot开始介绍，让读者最终学会如何创建Publish主题。</p></blockquote><h2>Plot</h2><h3>简介</h3><p>想要开发Publish的<code>Theme</code>主题，就不能不从Plot说起。</p><p>在Swift社区中，有不少优秀的项目致力于使用Swift生成HTML：比如Vapor的<a href="https://github.com/vapor/leaf" target="_blank">Leaf</a>，Point-Free的<a href="https://github.com/pointfreeco/swift-html" target="_blank">swift-html</a>等，Plot也是其中的一员。Plot最初是由<a href="https://swiftbysundell.com" target="_blank">John Sundell</a>编写的并作为Publish套件的一部分，它主要的关注点是Swift的静态网站HTML生成，以及创建建站所需的其他格式文档，包括<code>RSS</code>、<code>podcast</code>、<code>Sitemap</code>。它与Publish紧密集成但同时也作为一个独立项目存在。</p><p>Plot使用了一种被称作<code>Phantom Types</code>的技术，该技术将类型用作编译器的“标记”，从而能够通过泛型约束来强制类型安全。Plot使用了非常轻量级的A<a href=https://www.fatbobman.com/posts/publish-2>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/publish-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/publish-1</guid><title>用Publish创建博客（一）——入门</title><description>Publish是一款专门为Swift开发者打造的静态网站生成器。它使用Swift构建整个网站，并支持主题、插件和其他大量的定制选项。 本文包含Publish的快速使用入门以及基本结构说明。</description><link>https://www.fatbobman.com/posts/publish-1</link><pubDate>Sat, 30 Jan 2021 21:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p><a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a>是一款专门为Swift开发者打造的静态网站生成器。它使用Swift构建整个网站，并支持主题、插件和其他大量的定制选项。 作为Swift开发者，通过Publish创建站点的开发过程和体验同开发其他程序很类似。</p></blockquote><h2>开篇</h2><h3>开发者John Sundell</h3><p>Publish的开发者John Sundell这些年一直致力于发表关于Swift的高质量文章、播客和视频。他的作品大多都发布在其独立运营的 <a href="https://swiftbysundell.com/" target="_blank">Swift by Sundell</a>上。他开发了<a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a>用以创建并管理自己的站点。</p><p>在开发Publish的过程中，他还开源了其他大量的基本库，比如<a href="https://github.com/JohnSundell/Ink" target="_blank">Ink</a>（高效的Markdown解析器）、<a href="https://github.com/JohnSundell/Plot" target="_blank">Plot</a>（创建HTML、XML、RSS的DSL）、<a href="https://github.com/JohnSundell/Sweep" target="_blank">Sweep</a>（高效的字符串扫描库）、<a href="https://github.com/JohnSundell/Codextended" target="_blank">Codextended</a>（Codable增强）等。它们不仅一起构建了强大的Publish，并且在各自的领域也是极为出色的开源库。</p><h3>我为什么使用Publish</h3><p>我在一年前恢复自己的这个博客时使用的是<code>Hexo</code>。Hexo在国内有非常好的群众基础，网<a href=https://www.fatbobman.com/posts/publish-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/publish-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-ipad</guid><title>在SwiftUI下对iPad进行适配</title><description>SwiftUI创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记2.0开发初始，适配iPad便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配iPad的一些教训和心得。</description><link>https://www.fatbobman.com/posts/swiftui-ipad</link><pubDate>Thu, 29 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记2.0开发初始，适配iPad便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配iPad的一些教训和心得。</p></blockquote><h2>我是谁</h2><p>app中的代码必须能高效、清晰的了解当前设备的状况，时刻搞清楚我是谁，我在哪，在干啥等等。因此在项目开始之初我便做了不少的准备并创建了一系列的代码。</p><p>比如，当前的运行设备：</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Device</span> </span>{
    <span class="hljs-comment">//MARK:当前设备类型 iphone ipad mac</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Devicetype</span></span>{
        <span class="hljs-keyword">case</span> iphone,ipad,mac
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> deviceType:<span class="hljs-type">Devicetype</span>{
        #<span class="hljs-keyword">if</span> os(macOS)
        <span class="hljs-keyword">return</span> .mac
        #<span class="hljs-keyword">else</span>
        <span class="hljs-keyword">if</span>  <span class="hljs-type">UIDevice</span>.current.userInterfaceIdiom == .pad <a href=https://www.fatbobman.com/posts/swiftui-ipad>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-ipad>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coredata-in-swiftui</guid><title>聊一下在SwiftUI中使用CoreData</title><description>本文并非一个教你如何在SwiftUI下使用CoreData的教程。主要探讨的是在我近一年的SwiftUI开发中使用CoreData的教训、经验、心得。</description><link>https://www.fatbobman.com/posts/coredata-in-swiftui</link><pubDate>Wed, 28 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文并非一个教你如何在SwiftUI下使用CoreData的教程。主要探讨的是在我近一年的SwiftUI开发中使用CoreData的教训、经验、心得。</p></blockquote><h2>SwiftUI lifecycle 中如何声明持久化存储和上下文</h2><p>在XCode12中，苹果新增了SwiftUI lifecycle，让App完全的SwiftUI化。不过这就需要我们使用新的方法来声明持久化存储和上下文。</p><p>好像是从beta6开始，XCode 12提供了基于SwiftUI lifecycle的CoreData模板</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CoreDataTestApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-comment">//持久化声明</span>
    <span class="hljs-keyword">let</span> persistenceController = <span class="hljs-type">PersistenceController</span>.shared

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">ContentView</span>()
                .environment(<a href=https://www.fatbobman.com/posts/coredata-in-swiftui>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/coredata-in-swiftui>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthnote2-3rd-package</guid><title>介绍几个我在开发健康笔记2用到的Swift或SwiftUI第三方库</title><description>本文介绍了其中几个在健康笔记开发过程中使用的第三方的开源库</description><link>https://www.fatbobman.com/posts/healthnote2-3rd-package</link><pubDate>Tue, 27 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<h2><a href="https://github.com/SwiftUIX/SwiftUIX" target="_blank">SwiftUIX</a></h2><blockquote><p>SwiftUIX试图弥补仍处于新生阶段的SwiftUI框架的空白，提供了广泛的组件，扩展和实用程序套件来补充标准库。 迄今为止，该项目是缺少的UIKit / AppKit功能的最完整的移植，力求使其以大多数类似于Apple的方式交付。 这个项目的目标是补充SwiftUI标准库，提供数百种扩展和视图，使开发人员可以轻松地通过SwiftUI的革命来构建应用程序。</p></blockquote><p>提供了非常多的苹果本应提供但没有提供的功能扩展。项目的发起者非常年轻，但mac的开发经验十分丰富。到目前为止一直保持的较高的更新频率和维护状态。这个库同时支持UIKit和Appkit，对于需要做苹果生态全平台的用户十分友好。由于目前SwiftUI的List和LazyVStack的问题还很多，他自己在开发中也深受其苦，前天在交流中，他已经决定重做CocoaList功能，尤其提高对Fetchrequest的支持。</p><p>对于进行SwiftUI开发的朋友，它是十分值得推荐的。</p><p>目前的问题是文档太少。不过对我来说也未尝不是一个好事。在研<a href=https://www.fatbobman.com/posts/healthnote2-3rd-package>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthnote2-3rd-package>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-6</guid><title>健康笔记2.0开发随笔（六）</title><description>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同iOS14中的各种Bug和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊iOS14、Xcode12以及SwiftUI2.0的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-6</link><pubDate>Mon, 26 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>收尾工作往往是最枯燥的。</p><p>最近这10几天，主要的工作都是查找bug，改进性能，反复测试数据的稳定性，以及更加枯燥的文档准备工作。</p><p>向app store提交反倒异常顺利，中间只出现了一次反复。苹果要我确认是否会滥用用户的数据，在明确回复不会之后就通过了。想想去年底健康笔记1.0的上线反复折腾了我10多天。</p><p>XCode 12中的StoreKit对于调试应用内的购买实在是太方便了，在开发的最后阶段，我将app分成了基础版和专业版。基础版其实已经能应对生活中绝大多数的需求了。通过StoreKit的模拟环境，我的应用内购买没有使用任何沙盒测试便一次性的开发调试成功，并且上线后也运行正常。极大的提高了效率！</p><p>在本次历时近两个月的开发过程中，基本上没走太多弯路。真正让我消耗精力的反倒是和iOS 14以及SwiftUI 2.0中的Bug斗智斗勇。很多奇怪的问题，在对自己代码反复的检查之后才能基本确认是系统的原因，然后还需要设法用最少的代码重现问题得以最终确认。从WWDC20过后，目前已经给苹果提交了10几条的F<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-6>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-6>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthnote2-release</guid><title>健康笔记2.0正式版完成了!</title><description>经过了大半年的积累和准备,持续了2个月的开发,健康笔记2.0在昨天上线了.</description><link>https://www.fatbobman.com/posts/healthnote2-release</link><pubDate>Mon, 26 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>经过了大半年的积累和准备,持续了2个月的开发,健康笔记2.0在昨天上线了.</p><p>本次开发,我重写了健康笔记的全部代码,最后的结果个人还是比较满意的.</p><p>苹果在2020年无论从iOS,Swift,SwiftUI还是Xcode几个方面改进还是显著的,对我的帮助很大.</p><p>无论从功能、性能、UI表现上,2.0版都比1.0版有了较大提高.</p><p>在这里可以下载 <a href="https://apps.apple.com/us/app/health-notes-2/id1534513553"></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthnote2-release>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-5</guid><title>健康笔记2.0开发随笔（五）</title><description>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同iOS14中的各种Bug和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊iOS14、Xcode12以及SwiftUI2.0的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-5</link><pubDate>Wed, 7 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同iOS14中的各种Bug和异常斗智斗勇。</p><p>本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊iOS14、Xcode12以及SwiftUI2.0的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</p><h2>Bug实在多</h2><p>2020年苹果想在软件架构层面做出非常多的重要改变。big sur要支持arm，SwiftUI要真正做到一套代码顺利的多平台运行，iOS14也作出了在近几年肉眼可见的最大变化。不过可能是目标太多、太大，而时间又紧，至少到现在为止，bug层出不穷，改不胜改。尤其是随着版本的升级，竟然出现了不少前面完全不曾出现的bug，实在是令人心烦。</p><p>比如在iOS14.2beta2中，sheet的Delegate无法响应，而在之前的所有版本都没有问题。在iOS14.2beta2中，View的刷新时机有和之前有了细微的变化，在一些及特殊的情况下会出现刷新不同步。总之类似的错误一直在增加。</p><p>对于<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-5>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-5>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-4</guid><title>健康笔记2.0开发随笔（四）</title><description>本周没有太多的精力和情绪用来写代码。这两天在原来统一sheet管理和实时Form的基础上，完成了可以控制取消手势的Sheet。这个是SwiftUI中一直以来的一个重要的缺失功能。 在SwiftUI中制作可以控制取消手势的Sheet</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-4</link><pubDate>Thu, 17 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>经过2周的治疗,我父亲终于脱离的生命危险。疫情的原因，医院只允许一个护工在身边照顾，病人长时间无法见到家属而导致了较严重的心理问题。综合考虑，周末已接回家。回家2天后，整个状况有了非常好的转变。在这次的治疗中，我提供给医院的我父亲这几年来的各方面身体指标数据起到了很重要的作用。</p><p>本周没有太多的精力和情绪用来写代码。这两天在原来统一sheet管理和实时Form的基础上，完成了可以控制取消手势的Sheet。这个是SwiftUI中一直以来的一个重要的缺失功能。 <a href="https://www.fatbobman.com/posts/swiftui-dismiss-sheet/">在SwiftUI中制作可以控制取消手势的Sheet</a></p><p>Xcode 12 beta6 的bug还是不少，这两天我竟然见到了3次四国画面。 SwiftUI 2.0的List问题也很多，甚至感觉比1.0更不稳定，而且效率有明显的问题。目前已将所有使用List的地方都暂时替换成了LazyVStack。</p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-4>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-dismiss-sheet</guid><title>在SwiftUI中制作可以控制取消手势的Sheet</title><description>在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理app各个层级View的弹出Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在Sheet中制作一个可以实时响应的表单，并且sheet会感觉表单的情况响应取消手势。</description><link>https://www.fatbobman.com/posts/swiftui-dismiss-sheet</link><pubDate>Thu, 17 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理app各个层级View的弹出Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在Sheet中制作一个可以实时响应的表单，并且sheet会感觉表单的情况响应取消手势。</p></blockquote><p><a href="https://www.fatbobman.com/posts/swiftui-multiSheet/">在SwiftUI中,根据需求弹出不同的Sheet</a></p><p><a href="https://www.fatbobman.com/posts/swiftui-input-form/">如何在SwiftUI中创建一个实时响应的Form</a></p><h2>由来</h2><p>在之前Form的例子中，虽然我们可以根据表单是否进行了修改来对cancel、edit等做出不同的响应，但是我们并没有办法控制用户直接使用手势来取消sheet，为了不让用户绕过程序的判断检查，不得已使用了fullScreenCover来规避手势取消。不过在实际使用中，尽管全屏sheet提供了更多的屏幕可用空间，但还是会给使用者带来了操作逻辑不统一的体验。</p><p>在去年，我使用的解决方案是，屏蔽sheet的拖动手势。</p><pre data-language="swift"><code> .highPriorityGesture(<span class="hljs-type">DragGesture</span>())
</code></pre><p>这也是没有办法的办法。</p><p>后来，SwiftUI-lab中<a href=https://www.fatbobman.com/posts/swiftui-dismiss-sheet>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-dismiss-sheet>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-3</guid><title>健康笔记2.0开发随笔（三）</title><description>本周的由于其他琐事的原因,每天能够用于开发的时间基本上只能保证2-3个小时,所以进展不大.不过好在我也没有明确的进度指标.</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-3</link><pubDate>Sat, 5 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>由于家属突发疾病，最近每天都要出入医院，因此最近用于开发的时间很有限。</p><p>目前app已经完成了笔记、条目、数据的创建、编辑、显示、删除全部逻辑。如果不考虑图表、数据导入导出、交叉比对等功能，app的基本功能已经完成了。</p><p>在本次开发中，我着重调整了表单的开发方式，目前表单无论从响应，判断等方便都比上一版有了很大的提高。</p><p>本次我将以前分散的输入源（source of truth）统一到了一起，不仅更便于代码管理，同时也方便实现了很多以前无法或实现起来非常困难的功能。</p><p>关于表单的处理，可以参看我的文章<a href="https://www.fatbobman.com/posts/swiftui-input-form/">如何在SwiftUI中创建一个实时响应的Form</a>。</p><p>另外，由于我的app对于sheet的使用量也很多，所以也对sheet的响应做出了统一的管理，这方面我记录在另一篇文章中<a href="https://www.fatbobman.com/posts/swiftui-multiSheet/">在SwiftUI中,根据需求弹出不同的Sheet</a>。</p><p>时间有限，随便记录一点。</p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-3>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-input-form</guid><title>如何在SwiftUI中创建一个实时响应的Form</title><description>我的app健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的Form十分重要。本文尝试提出一个SwiftUI下的Form开发思路。</description><link>https://www.fatbobman.com/posts/swiftui-input-form</link><pubDate>Fri, 4 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>我的app健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的Form十分重要。本文尝试提出一个SwiftUI下的Form开发思路。</p></blockquote><h2>健康笔记1.0的时候</h2><p>在开发健康笔记1.0的使用，当时由于iOS13尚不支持onChange，当时主要使用类似的检查方式：</p><h2>对于简单情况</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>

<span class="hljs-type">TextField</span>(<span class="hljs-string">"name"</span>,text:$name)
     .foregroundColor(name.<span class="hljs-built_in">count</span>.isEmpty ? .red : .black)
</code></pre><h2>稍复杂的情况</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> age = <span class="hljs-string">""</span>

<span class="hljs-type">TextField</span>(<span class="hljs-string">"name"</span>,text:$name)
    .foregroundColor(!checkName() ? .red : .black)
<span class="hljs-type">TextField</span>(<span class="hljs-string">"age"</span>,text:$name)
     .keyboardType(.<a href=https://www.fatbobman.com/posts/swiftui-input-form>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-input-form>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-multiSheet</guid><title>在SwiftUI中,根据需求弹出不同的Sheet</title><description>Sheet是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在iOS14上，SwiftUI增加了fullCover，支持了全屏的Sheet方式，让开发者又了更多的选择。</description><link>https://www.fatbobman.com/posts/swiftui-multiSheet</link><pubDate>Fri, 4 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>Sheet是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在iOS14上，SwiftUI增加了fullCover，支持了全屏的Sheet方式，让开发者又了更多的选择。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> showView1 = <span class="hljs-literal">false</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> showView2 = <span class="hljs-literal">false</span>

<span class="hljs-type">List</span>{
    <span class="hljs-type">Button</span>(<span class="hljs-string">"View1"</span>){
      showView1.toggle()
    }
  .sheet(isPresented:$showView1){
    <span class="hljs-type">Text</span>(<span class="hljs-string">"View1"</span>)
  }
  
  <span class="hljs-type">Button</span>(<span class="hljs-string">"View2"</span>){
    showView2.toggle()
  }
  .sheet(isPresented:$showView2){
    <span class="hljs-type">Text</span>(<span class="hljs-string">"View2"</span>)
  }
}
</code></pre><p>上述代码，我们可以通过点击不同的按钮而弹出相对应的View。</p><p>不过它有两个缺点：</p><ol><li>如果你的代码有多处需要使用不同view作为shee<a href=https://www.fatbobman.com/posts/swiftui-multiSheet>...></a></li></ol><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-multiSheet>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-2</guid><title>健康笔记2.0开发随笔(二)</title><description>本周的由于其他琐事的原因,每天能够用于开发的时间基本上只能保证2-3个小时,所以进展不大.不过好在我也没有明确的进度指标.</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-2</link><pubDate>Mon, 24 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>本周的由于其他琐事的原因,每天能够用于开发的时间基本上只能保证2-3个小时,所以进展不大.不过好在我也没有明确的进度指标.</p><p>由于2.0在功能上同1.0的区别并不太大,所以在功能需求设计上不需要花费太多的时间.这半年来我自己也基本总结了一个自己用起来比较顺手的MVVM框架所以在最开始的1周,并不用太费力变完成了一个最简陋ui的原型版.</p><p>尽管叫原型版,但数据流、数据库操作等待基础代码都是要用于正式版中的.</p><p>在上周,苹果发布了Xcode12的beta5,其中提供了在SwiftUI lifecycle下的CoreData模版.所用的思路和我现在差不多.都是使用static来保证上下文的唯一性.另外苹果也提供了一个用于preview的思路,创建了一个in-memory 的Sqllite.这个也和我现在的途径差距不大,我现在是直接通过生成Sample NSManageObject给Preview来实现的.反正都是可以在preview中比较好的支持CoreData数据.</p><p>preview在Xcode12中得到了<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-2>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-list-foreach</guid><title>聊一下SwiftUI中的List和ForEach</title><description>在SwiftUI中使用List可以非常方便快速的制作各种列表.List其实就是对UITableView进行的封装.</description><link>https://www.fatbobman.com/posts/swiftui-list-foreach</link><pubDate>Mon, 24 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>在SwiftUI中使用List可以非常方便快速的制作各种列表.List其实就是对UITableView进行的封装(更多List的具体用法请参阅<a href="https://zhuanlan.zhihu.com/p/110749923" target="_blank">List基本用法</a>).</p><p>在List中添加动态内容,我们可以使用两种方式</p><h3>直接使用List自己提供的动态内容构造方法</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
    <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
  }
</code></pre><h3>在List中使用ForEach</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
    }
  }
</code></pre><p>在碰到我最近出现的问题之前,我一直以为上述两种用法除了极个别的区别外,基本没有什么不同.</p><p>当时知道的区别:</p><h3>使用ForEach可以在同一List中,添加多个动态源,且可添加静态内容</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(items,id:\.<span class="hljs-keyword">self</span>){ item <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(item)
    }
    <span class="hljs-type">Text</span>(<span class="hljs-string">"其他内容"</span>)
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..<a href=https://www.fatbobman.com/posts/swiftui-list-foreach>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-list-foreach>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-1</guid><title>健康笔记2.0开发随笔（一）</title><description>健康笔记从2020年1月上线以来，至今已经过了大半年的时间（可以从[老人新兵 —— 一款iOS app的开发手记](https://zhuanlan.zhihu.com/p/103822455)了解健康笔记app的由来）。在这段时间里，我对于Swift、SwiftUI、CoreData等都有了进一步的了解和认识。在开发1.0版本时所面对的问题和疑惑多数都得到了解决。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-1</link><pubDate>Mon, 17 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>健康笔记从2020年1月上线以来，至今已经过了大半年的时间（可以从<a href="https://zhuanlan.zhihu.com/p/103822455" target="_blank">老人新兵 —— 一款iOS app的开发手记</a>了解健康笔记app的由来）。在这段时间里，我对于Swift、SwiftUI、CoreData等都有了进一步的了解和认识。在开发1.0版本时所面对的问题和疑惑多数都得到了解决。</p></blockquote><p>最近随着iOS14发布的临近，同时也想将这短时间来学习的知识进行更系统的整理和应用，于是便将健康笔记2.0的开发工作提上了日程，并已经着手进行中。</p><h2>健康笔记2.0的规</h2><ul><li>功能</li></ul><p>健康笔记1.0目前的功能已基本能够满足我个人的日常使用，在上线这段时间内，我也根据用户提出的建议增加了部分新功能。因此在2.0上，app核心功能的增加并不是太多，主要集中在两点：</p><ul><li>数据类型</li></ul><p>1.0中当前支持两种数据类型，一种是数字型（仅记录一个数字+日期），另一个是选项型（自定义选项内容+日期），在2.0中，新增了其他5中数据类型包括：双数字型、数字选项型、起始时间型等。使用者可以记录生活中更多种类的内容。</p><ul><li>数据导入导出</li></ul><p>1.0中已经提供了对于数字卡片<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swifui-overlay</guid><title>SwiftUIOverlayContainer ——可以实现各种自定义样式弹出视图的SwitUI库</title><description>SwiftUI目前可以提供sheet,fullScreenCover,alert,actionsheet等弹出视图用于丰富UI交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的SwiftUI库 —— SwiftUIOverlayContainer。</description><link>https://www.fatbobman.com/posts/swifui-overlay</link><pubDate>Wed, 12 Aug 2020 16:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI目前可以提供sheet,fullScreenCover,alert,actionsheet等弹出视图用于丰富UI交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的SwiftUI库 —— SwiftUIOverlayContainer。</p></blockquote><p>SwiftUIOverlayContainer本身并不提供任何预置的视图样式，不过通过它，你有充分的自有度来实现自己需要的视图效果。OverlayContainer的主要目的在于帮助你完成动画、交互、样式定制等基础工作，使开发者能够将时间和精力仅需投入在视图本身的代码上。</p><p><a href="https://github.com/fatbobman/SwiftUIOverlayContainer" target="_blank">SwiftUIOverlayContainer</a></p><video src="https://cdn.fatbobman.com/swiftui-overlay-demo.mp4" controls = "controls">你的浏览器不支持本视频</video><p>库代码已经修改可以直接在xcode11下使用</p><p>代码思路受到了<a href="https://link.zhihu.com/?target=https%3A//github.com/AndreaMiotto/PartialSheet" target="_blank">PartialSheet</a>很大的影响,并使用了其部分代码。</p><h2>使用方法</h2><ol><li>Add a <strong>OverlayContainerManager</strong> instance as an <em>environment object</em> to your Root <a href=https://www.fatbobman.com/posts/swifui-overlay>...></a></li></ol><br><br><h3><a href=https://www.fatbobman.com/posts/swifui-overlay>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swipeCell</guid><title>用SwiftUI实现iOS mail程序的侧滑菜单</title><description>随着SwiftUI2.0的不断完善，我觉得是时候将我的app做一个较大的升级了。之前一直想在app中实现类似iOS 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于UIKit的，基本上没有能够很好的适配SwiftUI的项目库。最终自己在Xcode12实现了一个。</description><link>https://www.fatbobman.com/posts/swipeCell</link><pubDate>Wed, 12 Aug 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>随着SwiftUI2.0的不断完善，我觉得是时候将我的app做一个较大的升级了。之前一直想在app中实现类似iOS 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于UIKit的，基本上没有能够很好的适配SwiftUI的项目库。最终自己在Xcode12实现了一个。</p></blockquote><p>SwipeCell 是一个用Swift 5.3开发的 SwiftUI库.目标是为了实现类似iOS Mail程序实现的左右滑动菜单功能. SwipeCell 需要 XCode 12 ,iOS 14</p><p><a href="https://github.com/fatbobman/SwipeCell" target="_blank">SwipeCell GitHub</a></p><video src="https://cdn.fatbobman.com/SwipeCellDemoVideo.mp4" controls = "controls">你的浏览器不支持本视频</video><h2>配置Button</h2><pre data-language="swift"><code><span class="hljs-keyword">let</span> button1 = <span class="hljs-type">SwipeCellButton</span>(buttonStyle: .titleAndImage,
                title: <span class="hljs-string">"Mark"</span>, 
                systemImage: <span class="hljs-string">"bookmark"</span>,
                titleColor: .white, 
       <a href=https://www.fatbobman.com/posts/swipeCell>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swipeCell>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-import-export</guid><title>HowTo —— SwiftUI2.0 文件导入导出</title><description>SwiftUI2.0中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。</description><link>https://www.fatbobman.com/posts/howto-swiftui-import-export</link><pubDate>Tue, 28 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。</p></blockquote><h2>更新</h2><p>目前SwiftUI大幅度的修改了导入导出的用法.</p><p>fileImporter fileExporter fileMover 分别对应 导入、导出、移动</p><p>示例如下:</p><pre data-language="swift"><code>  .fileImporter(isPresented: showImport, allowedContentTypes: [.<span class="hljs-built_in">zip</span>], onCompletion: {
            result <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">switch</span> result{
            <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> url):
                <span class="hljs-built_in">print</span>(store.dataHandler.importData(url))
            <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
                <span class="hljs-built_in">print</span>(error)
         <a href=https://www.fatbobman.com/posts/howto-swiftui-import-export>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-import-export>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader</guid><title>HowTo —— SwiftUI2.0使用ScrollViewReader定位滚动位置</title><description>SwiftUI2.0增加了滚动定位功能,已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案,并不是通过设置具体的offset来进行定位,而是使用id来进行位置标记。</description><link>https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader</link><pubDate>Thu, 23 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0增加了滚动定位功能,已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案,并不是通过设置具体的offset来进行定位,而是使用id来进行位置标记。</p></blockquote><h2>基本用法——实现从右向左滚动</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ScrollReaderTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>(.horizontal) {
            <span class="hljs-comment">//类似GeometryReader的使用方式，设定滚动定位区域</span>
            <span class="hljs-type">ScrollViewReader</span>{ proxy <span class="hljs-keyword">in</span>
                <span class="hljs-type">Rectangle</span>()
                    .fill(<span class="hljs-type">LinearGradient</span>(
                      gradient: <span class="hljs-type">Gradient</span>(colors: [.blue,.red]),
                      startPoi<a href=https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-progressView</guid><title>HowTo —— SwiftUI2.0 使用ProgressView显示进度条</title><description>SwiftUI2.0 新增了一些便捷的内置控件，比如说Label、ProgressView等。其基本形态都很普通，不过都支持自定义style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展style来完成。</description><link>https://www.fatbobman.com/posts/howto-swiftui-progressView</link><pubDate>Sun, 12 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0 新增了一些便捷的内置控件，比如说Label、ProgressView等。其基本形态都很普通，不过都支持自定义style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展style来完成。</p></blockquote><h2>经典小菊花</h2><pre data-language="swift"><code><span class="hljs-type">ProgressView</span>()
</code></pre><h2>线性进度条</h2><pre data-language="swift"><code><span class="hljs-type">ProgressView</span>(<span class="hljs-string">"完成量"</span>, value: <span class="hljs-number">50</span>, total: <span class="hljs-number">100</span>)
</code></pre><img src="https://cdn.fatbobman.com/howto-swiftui-progressView-progress2.png" alt="截屏2020-07-11 下午4.09.34"/><h2>代码示例</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProgressTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> timer = <span class="hljs-type">Timer</span>.<span class="hljs-type">TimerPublisher</span>(interval: <span class="hljs-number">0.03</span>, runLoop: .main, mode: .common).autoconnect()
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> value:<span class="hljs-type">Double</span> = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-comment">//无法定义颜色</span>
         <a href=https://www.fatbobman.com/posts/howto-swiftui-progressView>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-progressView>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl</guid><title>HowTo —— 使用onOpenURL处理Universal Links</title><description>SwiftUI2.0由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织app,因此提供了onOpenURL来处理Univeresal Links。不同于在AppDelegate或SceneDelegate中的解决方案，onOpenURL作为一个view modifier，你可以在任意View上注册你的app的URL处理机制。</description><link>https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl</link><pubDate>Sat, 11 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织app,因此提供了onOpenURL来处理Univeresal Links。不同于在AppDelegate或SceneDelegate中的解决方案，onOpenURL作为一个view modifier，你可以在任意View上注册你的app的URL处理机制。关于如何为自己的app创建URL Scheme，请参阅<a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app" target="_blank">苹果的官方文档</a>。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-type">VStack</span>{
   <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello World"</span>)
}
.onOpenURL{ url <span class="hljs-keyword">in</span>
    <span class="hljs-comment">//做点啥</span>
}
</code></pre><h2>示例代码</h2><p>首先在项目中设置URL</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> tabSelection:<span class="hljs-type">TabSelection</span> = .news
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> show = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">T<a href=https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-toolbar</guid><title>HowTo —— SwiftUI2.0 使用ToolBar替代navigationbarItems</title><description>SwiftUI2.0为了实现更好的多平台支持同时需要兼顾1.0版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如ToolBar, navigationTitle等。Toolbar可以实现navigationbarItems的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。</description><link>https://www.fatbobman.com/posts/howto-swiftui-toolbar</link><pubDate>Fri, 10 Jul 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0为了实现更好的多平台支持同时需要兼顾1.0版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如ToolBar, navigationTitle等。Toolbar可以实现navigationbarItems的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。 <strong>在当前的Xcode Version 12.0 beta 2 (12A6163b)版本下，ToolBar在macOS下仍然有非常多的问题。</strong></p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ToolBarTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
      <span class="hljs-type">NavigationView</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"ToolBar 演示"</span>)
            .toolbar{
                <span class="hljs-type">ToolbarItem</span>(placement:.automatic){
                    <span class="hljs-type">HStack</span>(spacing:<span class="hljs-number">20</span>){
    <a href=https://www.fatbobman.com/posts/howto-swiftui-toolbar>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-toolbar>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-link-openurl</guid><title>HowTo —— SwiftUI2.0 使用Link或openURL打开URL scheme</title><description>SwiftUI2.0提供了原生的打开URL scheme的功能，我们可以十分方便的在代码中调用其他的app。</description><link>https://www.fatbobman.com/posts/howto-swiftui-link-openurl</link><pubDate>Fri, 10 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0提供了原生的打开URL scheme的功能，我们可以十分方便的在代码中调用其他的app。</p></blockquote><h2>Link</h2><p>类似于 NavigationLink ,直接打开URL scheme对应的app</p><pre data-language="swift"><code><span class="hljs-type">Link</span>(<span class="hljs-string">"openURL"</span>,destination:safariUrl)
</code></pre><h2>openURL</h2><p>本次在SwiftUI2.0中，苹果提供了若干个通过Environment注入的调用系统操作的方法。比如 exportFiles,importFiles,openURL等。</p><pre data-language="swift"><code>@<span class="hljs-type">Environment</span>(\.openURL) <span class="hljs-keyword">var</span> openURL
openURL.callAsFunction(url)
</code></pre><h2>代码范例</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">URLTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Environment</span>(\.openURL) <span class="hljs-keyword">var</span> openURL
    <span class="hljs-keyword">let</span> safariUrl = <span class="hljs-type">URL</span>(string:<span class="hljs-string">"http://www.apple.com"</span>)!
    <span class="hljs-keyword">let</span> mailUrl = <span class="hljs-type">URL</span>(string:<span class="hljs-string">"mailt<a href=https://www.fatbobman.com/posts/howto-swiftui-link-openurl>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-link-openurl>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-grid</guid><title>HowTO —— SwiftUI2.0 原生的Grid</title><description>SwiftUI的第一版中，官方并没有提供UICollectionView的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI2.0中，苹果通过LazyVGrid、LazyHGrid提供了Grid控件。该控件的实现很有SwiftUI的风格，和众多的第三方库有显著的区别。</description><link>https://www.fatbobman.com/posts/howto-swiftui-grid</link><pubDate>Fri, 10 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI的第一版中，官方并没有提供UICollectionView的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI2.0中，苹果通过LazyVGrid、LazyHGrid提供了Grid控件。该控件的实现很有SwiftUI的风格，和众多的第三方库有显著的区别。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GridTest1</span>: <span class="hljs-title">View</span> </span>{
    
    <span class="hljs-keyword">let</span> columns = [
        <span class="hljs-type">GridItem</span>(.adaptive(minimum: <span class="hljs-number">50</span>))
        <span class="hljs-comment">//adaptive自适应，在一行或一列中放入尽可能多的Item</span>
        <span class="hljs-comment">//fixed完全固定的尺寸 GridItem(.fixed(50)), 需显式设置每行或每列中放入的item数量</span>
        <span class="hljs-comment">//flexible用法类似fixed，不过每个item的尺寸可以弹性调整，同样需要显式设置item数量</span>
        <span class="hljs-comment">//可以混用</span>
    ]
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">V<a href=https://www.fatbobman.com/posts/howto-swiftui-grid>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-grid>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-label</guid><title>HowTo —— SwiftUI2.0如何使用Label</title><description>SwiftUI2.0中新增了Label控件，方便我们添加由图片和文字组成的标签.</description><link>https://www.fatbobman.com/posts/howto-swiftui-label</link><pubDate>Thu, 9 Jul 2020 13:05:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0中新增了Label控件，方便我们添加由图片和文字组成的标签</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-type">Label</span>(<span class="hljs-string">"Hello World"</span>,systemImage:<span class="hljs-string">"person.badge.plus"</span>)
</code></pre><h2>支持自定义标签风格</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LabelTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>(<span class="hljs-type">LabelItem</span>.labels(),id:\.id){ label <span class="hljs-keyword">in</span>
            <span class="hljs-type">Label</span>(label.title,systemImage:label.image)
                .foregroundColor(.blue)
                .labelStyle(<span class="hljs-type">MyLabelStyle</span>(color:label.color))
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyLabelStyle</span>:<span class="hljs-title">LabelStyle</span></span>{
    <span class="hljs-keyword">let</span> color:<span class="hljs-type">Color</span>
<a href=https://www.fatbobman.com/posts/howto-swiftui-label>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-label>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-lazyStack</guid><title>HowTo —— SwiftU2.0 LazyVStack,LazyHStack</title><description>SwiftUI2.0提供了LazyVStack和LazyHStack，其作用是只有当View在可见区域内才进行渲染，这样可以大大大提高app执行效率</description><link>https://www.fatbobman.com/posts/howto-swiftui-lazyStack</link><pubDate>Thu, 9 Jul 2020 13:05:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0提供了LazyVStack和LazyHStack，其作用是只有当View在可见区域内才进行渲染，这样可以大大大提高app执行效率。由于VStack或HStack导致的效率问题，在<a href="https://zhuanlan.zhihu.com/p/111151515" target="_blank">SwiftUI List (3) —— List、Form、VStack</a>文章中有简单的比较。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LazyStack</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>{
            <span class="hljs-type">LazyVStack</span>{ <span class="hljs-comment">//换成VStack作比较新数据创建的时机</span>
                <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>...<span class="hljs-number">1000</span>,id:\.<span class="hljs-keyword">self</span>){ id <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Text</span>(<span class="hljs-type">LazyItem</span>(id:id).title)
                }
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LazyItem</span></span>{
    <span class="hljs-keyword">let</span> id:<span class="hljs-type">Int</span>
  <a href=https://www.fatbobman.com/posts/howto-swiftui-lazyStack>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-lazyStack>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-map</guid><title>HowTo—— Swift2.0在视图中显示地图</title><description>Swift2.0中，苹果添加了Map，让开发者可以非常容易的在View中添加需要的地图元素。本文简单介绍了其用法</description><link>https://www.fatbobman.com/posts/howto-swiftui-map</link><pubDate>Thu, 9 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>Swift2.0中，苹果添加了Map，让开发者可以非常容易的在View中添加需要的地图元素。</p></blockquote><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI
<span class="hljs-keyword">import</span> MapKit

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MapView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-comment">//设置初始显示区域</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> region:<span class="hljs-type">MKCoordinateRegion</span> = <span class="hljs-type">MKCoordinateRegion</span>(
        center: <span class="hljs-type">CLLocationCoordinate2D</span>(latitude: <span class="hljs-number">38.92083</span>, longitude: <span class="hljs-number">121.63917</span>),
        span: <span class="hljs-type">MKCoordinateSpan</span>(latitudeDelta: <span class="hljs-number">0.5</span>, longitudeDelta: <span class="hljs-number">0.5</span>)
    )
    
    <span class="hljs-comment">//设置是否持续跟踪用户当前位置</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> trackmode = <span class="hljs-type">MapUserTrackingMode</span>.follow
    
    <span class="hljs-comment">//设置标记点信息</span><a href=https://www.fatbobman.com/posts/howto-swiftui-map>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-map>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui2-new-feature-2</guid><title>SwiftUI2.0 —— App、Scene、新的代码结构（二）</title><description>在上篇文章中我们简单了解了App、Scene，以及几个内置Scene的应用。在本文中，我们着重探讨在SwiftUI2.0新的代码结构下如果更高效的组织Data Flow。</description><link>https://www.fatbobman.com/posts/swiftui2-new-feature-2</link><pubDate>Wed, 8 Jul 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在<a href="https://www.fatbobman.com/posts/swiftui2-new-feature-1/">上篇文章</a>中我们简单了解了App、Scene，以及几个内置Scene的应用。在本文中，我们着重探讨在SwiftUI2.0新的代码结构下如果更高效的组织Data Flow。</p></blockquote><h2>新特性</h2><h3>@AppStorage</h3><p>AppStorage是苹果官方提供的用于操作UserDefault的属性包装器。这个功能在Swift提供了propertyWrapper特性后，已经有众多的开发者编写了类似的代码。功能上没有任何特别之处，不过名称对应了新的App协议，让人更容易了解其可适用的周期。</p><ul><li>数据可持久化，app退出后数据仍保留</li><li>仅包装了UserDefault，数据可以UserDefault正常读取</li><li>可保存的数据类型同UserDefault，不适合保存复杂类型数据</li><li>在app的任意View层级都可适用，不过在app层使用并不起作用（不报错）</li></ul><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppStorageTest</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-comment">//不报错，不过不起作用</span>
    <span class="hljs-comment">//@AppStorage("count") var count = 0</span>
    <span class="hljs-keyword"><a href=https://www.fatbobman.com/posts/swiftui2-new-feature-2>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui2-new-feature-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui2-new-feature-1</guid><title>SwiftUI2.0 —— App、Scene、新的代码结构（一）</title><description>本文简单介绍了SwiftUI2.0中全新提供的App协议、Scene协议，浅谈了在全新的代码结构下如何组织Data Flow，并提供了SwiftUI2.0中预置的Scene的一些使用示例。当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta版(20A4299v)。</description><link>https://www.fatbobman.com/posts/swiftui2-new-feature-1</link><pubDate>Wed, 8 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文简单介绍了SwiftUI2.0中全新提供的App协议、Scene协议，浅谈了在全新的代码结构下如何组织Data Flow，并提供了SwiftUI2.0中预置的Scene的一些使用示例。 当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta版(20A4299v)。</p></blockquote><p>WWDC20中，苹果为开发者带来了基于SwiftUI的全新项目模板。使用该模板，将使项目代码变得异常简洁、清晰。</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello world"</span>)
        }
    }
}
</code></pre><p>上述代码可以在屏幕上完成Hello world的显示，且能够运行于iOS和macOS平台下。</p><h2>基本概念</h2><h3>App</h3><p>SwiftUI2.0提供的全新协议。通过声明一个符合App协议的结构来创建一个<a href=https://www.fatbobman.com/posts/swiftui2-new-feature-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui2-new-feature-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/focusedBinding</guid><title>@FocusedBinding 浅谈</title><description>在苹果WWDC20中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding在目前Xcode Version 12.0 beta 2 (12A6163b)的版本上运行还有很多问题，但我基本上对其有了一定的了解。</description><link>https://www.fatbobman.com/posts/focusedBinding</link><pubDate>Sun, 5 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在苹果WWDC20中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding在目前Xcode Version 12.0 beta 2 (12A6163b)的版本上运行还有很多问题，但我基本上对其有了一定的了解。</p></blockquote><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BookCommands</span>: <span class="hljs-title">Commands</span> </span>{
 @<span class="hljs-type">FocusedBinding</span>(\.selectedBook) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> selectedBook: <span class="hljs-type">Book?</span>
  <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Commands</span> {
    <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Book"</span>) {
        <span class="hljs-type">Section</span> {
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Update Progress..."</span>, action: updateProgress)
<a href=https://www.fatbobman.com/posts/focusedBinding>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/focusedBinding>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftUI2-commands</guid><title>SwiftUI2.0 —— Commands（macOS菜单）</title><description>本文介绍了SwiftUI 2.0中，如何为macOS平台添加菜单。苹果在SwiftUI2.0中增加了Multiplatform项目模板，使得同一套代码，仅需少量的适配便可以同时满足iOS以及macOS的需要。对于macOS上运行的app,拥有自定义的菜单是一个十分重要的平台特征。对于没有macOS开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。</description><link>https://www.fatbobman.com/posts/swiftUI2-commands</link><pubDate>Sat, 27 Jun 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文介绍了SwiftUI 2.0中，如何为macOS平台添加菜单。 当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta版(20A4299v)。</p></blockquote><p>苹果在SwiftUI2.0中增加了Multiplatform项目模板，使得同一套代码，仅需少量的适配便可以同时满足iOS以及macOS的需要。对于macOS上运行的app,拥有自定义的菜单是一个十分重要的平台特征。对于没有macOS开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。</p><h2>基础</h2><p>在SwiftUI下为app添加菜单十分方便，下面的代码便可以为app添加一个最基础的菜单。</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CommandExampleApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
           <span class="hljs-type">ContentView</span>()
        }
        .commands{
     <a href=https://www.fatbobman.com/posts/swiftUI2-commands>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftUI2-commands>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/stateobject</guid><title>SwiftUI 2.0 —— @StateObject 研究</title><description>WWDC20刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下SwiftUI新提供的属性包装器@StateObject。</description><link>https://www.fatbobman.com/posts/stateobject</link><pubDate>Fri, 26 Jun 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>WWDC20刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下SwiftUI新提供的属性包装器@StateObject。</p></blockquote><h2>为什么要新增@StateObject</h2><p>在我之前的文章<a href="https://www.fatbobman.com/posts/swiftUI-state/">@State研究</a>中我们探讨过@State，通过它，我们可以方便的将值类型数据作为View的Source of truth。在SwiftUI 1.0时代，如果想将引用类型作为source of truth,通常的方法是使用@EnvironmentObject或者 @ObservedObject。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RootView</span>:<span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">ContentView</span>()
            .environmentObject(<span class="hljs-type">Store</span>())
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Environment<a href=https://www.fatbobman.com/posts/stateobject>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/stateobject>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/observableObject-study</guid><title>ObservableObject研究——想说爱你不容易</title><description>本文主要研究在SwiftUI中，采用单一数据源(Single Source of Truth)的开发模式，ObservableObject是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用ObservableObject的方式。</description><link>https://www.fatbobman.com/posts/observableObject-study</link><pubDate>Sun, 17 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文主要研究在SwiftUI中，采用单一数据源(Single Source of Truth)的开发模式，ObservableObject是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用ObservableObject的方式。</p></blockquote><h2>单一数据源</h2><p>我是在去年阅读王巍写的<a href="https://objccn.io/products/swift-ui" target="_blank">《SwiftUI 与 Combine 编程》</a>才第一次接触到<strong>单一数据源</strong>这一概念的。</p><ul><li>将 app 当作一个状态机，状态决定用户界面。</li></ul><ul><li>这些状态都保存在一个 Store 对象中，被称为 State。</li></ul><ul><li>View 不能直接操作 State，而只能通过发送 Action 的方式，间接改变存储在 Store 中的 State。</li></ul><ul><li>Reducer 接受原有的 State 和发送过来的 Action，生成新的 State。</li></ul><ul><li>用新的 State 替换 Store 中原有的状态，并用新状态来驱动更新界面。</li></ul><p>在该书中结合作者之前Redux、RxSwift等开发经验，提供了一个SwiftUI化的<a href=https://www.fatbobman.com/posts/observableObject-study>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/observableObject-study>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftUI-state</guid><title>@state研究</title><description>本文试图探讨并分析SwiftUI 中 @State的实现方式和运行特征；最后提供了一个有关扩展@State功能的思路及例程。读者需要对SwiftUI的响应式编程有基本概念。</description><link>https://www.fatbobman.com/posts/swiftUI-state</link><pubDate>Sun, 17 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文试图探讨并分析SwiftUI 中 @State的实现方式和运行特征；最后提供了一个有关扩展@State功能的思路及例程。读者需要对SwiftUI的响应式编程有基本概念。</p></blockquote><h2>研究的意义何在</h2><p>我在去年底使用了SwiftUI写了第一个 iOS app <strong>健康笔记</strong>，这是我第一次接触响应式编程概念。在有了些基本的认识和尝试后，深深的被这种编程的思路所打动。不过，我在使用中也发现了一些奇怪的问题。就像之前在 <a href="https://zhuanlan.zhihu.com/p/103822455" target="_blank">老人新兵</a> 中说的那样，我发现在视图（View）数量达到一定程度，随着数据量的增加，整个app的响应有些开始迟钝，变得有粘滞感、不跟手。app响应出现了问题一方面肯定和我的代码效率、数据结构设计欠佳有关；不过随着继续分析，发现其中也有很大部分原因来自于SwiftUI中所使用的响应式的实现方式。不恰当的使用，可能导致响应速度会随着数据量及View量的增加而大幅下降。通过一段时间的研究和分析，我打算用两篇文章来阐述这方面的问题，并尝试提供一个现阶段的使用思路。</p><h2>数据（状态）驱动</h2><p>在SwiftUI中，视图是由数<a href=https://www.fatbobman.com/posts/swiftUI-state>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/swiftUI-state>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/vapor4</guid><title>Vapor4 的安装与配置</title><description>本文介绍了如何在mac 10.5.4和ubuntu 18.04下安装Vapor命令行工具，创建Vapor项目，简单的调试项目以及如何部署到生产环境的过程。文中的运行环境为: Vapor4,Swift5.2,Catalina 10.5.4,Ubuntu18.04</description><link>https://www.fatbobman.com/posts/vapor4</link><pubDate>Thu, 7 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文介绍了如何在mac 10.5.4和ubuntu 18.04下安装Vapor命令行工具，创建Vapor项目，简单的调试项目以及如何部署到生产环境的过程。文中的运行环境为: Vapor4,Swift5.2,Catalina 10.5.4,Ubuntu18.04</p></blockquote><p>最近新开通了一个云服务器（Linux系统），使用<a href="https://hexo.io/zh-cn/index.html/" target="_blank">Hexo</a>创建了新的博客网页。考虑增加点简单的交互功能，所以需要在服务器端添加逻辑处理能力。由于近半年来基本上都是在使用Swift，所以打算尝试一下Server Side Swift。没有太仔细选择各种框架，看过几个介绍Vapor使用的视频后，感觉不错，便开始尝试安装配置。</p><p>Vapor的官方文档实在是有很大的问题，网上的不少心得、教程又有点陈旧（目前版本调整较大）。通过两天的折腾，终于基本上理出了脉络，初步搭建了开发和生产环境。</p><h2>什么是Vapor</h2><p><a href="https://github.com/vapor/vapor" target="_blank">Vapor</a>是一个使用swift语言编写的Web网络框架，它是跨平台的（mac、Linux），用户可以使用swift语言以及其丰富的第三方库来高效的完<a href=https://www.fatbobman.com/posts/vapor4>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/vapor4>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/first-post</guid><title>时隔多年，重新创建了博客</title><description>用Hexo创建了一个博客，主要记录自己在开发健康笔记过程中的一点心得和技术总结。</description><link>https://www.fatbobman.com/posts/first-post</link><pubDate>Thu, 30 Apr 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>用Hexo创建了一个博客，主要记录自己在开发健康笔记过程中的一点心得和技术总结。</p><br><br><h3><a href=https://www.fatbobman.com/posts/first-post>查看全文</a></h3>]]></content:encoded></item></channel></rss>